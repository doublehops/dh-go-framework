package {{.LowerCase}}service

import (
	"context"
	"fmt"

	"{{.Module}}/internal/model/{{.LowerCase}}"
	"{{.Module}}/internal/logga"
	"{{.Module}}/internal/repository/{{.LowerCase}}repository"
	"{{.Module}}/internal/service"
	req "{{.Module}}/internal/request"
)

type {{.PascalCase}}Service struct {
	*service.App
	{{.CamelCase}}Repo *{{.LowerCase}}repository.Repo
}

func New(app *service.App, {{.LowerCase}}Repo *{{.LowerCase}}repository.Repo) *{{.PascalCase}}Service {
	return &{{.PascalCase}}Service{
		App:        app,
		{{.CamelCase}}Repo: {{.LowerCase}}Repo,
	}
}

func (s *{{.PascalCase}}Service) Create(ctx context.Context, record *{{.LowerCase}}.{{.PascalCase}}) (*{{.LowerCase}}.{{.PascalCase}}, error) {
	if err := record.SetCreated(ctx); err != nil {
		s.Log.Error(ctx, "error in SetCreated", logga.KVPs{"error": err.Error()})
	}

	tx := s.DB.MustBegin()
	defer tx.Rollback() // nolint: errcheck

	err := s.{{.CamelCase}}Repo.Create(ctx, tx, record)
	if err != nil {
		s.Log.Error(ctx, "unable to save new record. "+err.Error(), nil)

		return record, req.ErrCouldNotSaveRecord
	}

	err = tx.Commit()
	if err != nil {
		s.Log.Error(ctx, "unable to commit transaction"+err.Error(), nil)
	}

	a := &{{.CamelCase}}.{{.PascalCase}}{}
	err = s.{{.CamelCase}}Repo.GetByID(ctx, s.DB, record.ID, a)
	if err != nil {
		s.Log.Error(ctx, "unable to retrieve record. "+err.Error(), nil)
	}

	return a, nil
}

func (s *{{.PascalCase}}Service) Update(ctx context.Context, record *{{.LowerCase}}.{{.PascalCase}}) (*{{.LowerCase}}.{{.PascalCase}}, error) {
	record.SetUpdated(ctx)

	tx := s.DB.MustBegin()
	defer tx.Rollback() // nolint: errcheck

	err := s.{{.CamelCase}}Repo.Update(ctx, tx, record)
	if err != nil {
		s.Log.Error(ctx, "unable to update record. "+err.Error(), nil)
	}

	err = tx.Commit()
	if err != nil {
		s.Log.Error(ctx, "unable to commit transaction"+err.Error(), nil)
	}

	a := &{{.CamelCase}}.{{.PascalCase}}{}
	err = s.{{.CamelCase}}Repo.GetByID(ctx, s.DB, record.ID, a)
	if err != nil {
		s.Log.Error(ctx, "unable to retrieve record. "+err.Error(), nil)
	}

	return a, nil
}

func (s *{{.PascalCase}}Service) DeleteByID(ctx context.Context, record *{{.LowerCase}}.{{.PascalCase}}) error {
	tx := s.DB.MustBegin()
	defer tx.Rollback() // nolint: errcheck

	record.SetDeleted(ctx)

	err := s.{{.CamelCase}}Repo.Delete(ctx, tx, record)
	if err != nil {
		s.Log.Error(ctx, "unable to delete record. "+err.Error(), nil)

		return fmt.Errorf("unable to delete record")
	}

	err = tx.Commit()
	if err != nil {
		s.Log.Error(ctx, "unable to commit transaction"+err.Error(), nil)
	}

	return nil
}

func (s *{{.PascalCase}}Service) GetByID(ctx context.Context, record *{{.LowerCase}}.{{.PascalCase}}, ID int32) error {
	err := s.{{.CamelCase}}Repo.GetByID(ctx, s.DB, ID, record)
	if err != nil {
		s.Log.Error(ctx, "unable to retrieve record. "+err.Error(), nil)
	}

	return nil
}

func (s *{{.PascalCase}}Service) GetAll(ctx context.Context, r *req.Request) ([]*{{.LowerCase}}.{{.PascalCase}}, error) {
	records, err := s.{{.CamelCase}}Repo.GetCollection(ctx, s.DB, r)
	if err != nil {
		s.Log.Error(ctx, "unable to update new record. "+err.Error(), nil)
	}

	return records, nil
}
